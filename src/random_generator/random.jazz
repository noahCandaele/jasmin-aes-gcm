export fn random32() -> reg u32 {
	reg u32 res;
	stack u32[1] r;
	reg ptr u32[1] p;
	p = r;
	p = #randombytes(p);
	r = p;
	res = r[0];
	return res;
}

export fn random64() -> reg u64 {
	reg u64 res;
	stack u64[1] r;
	reg ptr u64[1] p;
	p = r;
	p = #randombytes(p);
	r = p;
	res = r[0];
	return res;
}

export fn random128() -> reg u128 {
	reg u128 res;
	stack u128[1] r;
	reg ptr u128[1] p;
	p = r;
	p = #randombytes(p);
	r = p;
	res = r[0];
	return res;
}

export fn iv_init() -> reg u128 {
	// reg u32 rand32;
	// #inline rand32 = random32();

	// reg u64 rand64;
	// #inline rand64 = random64();

	// reg u128 res;
	// res = (128u)rand64;

	// reg u128 rand32_u128;
	// rand32_u128 = (128u)rand32;

	// // https://www.felixcloutier.com/x86/pshufd
	// res = #VPSHUFD(rand32_u128, 0x0C);

	reg u32 rand32;
	// #inline rand32 = random32();
	rand32 = 0x12345678;

	reg u128 rand32_u128;
	rand32_u128 = (128u)rand32;

	reg u64 rand64;
	// #inline rand64 = random64();
	rand64 = 0xaaaabbbbccccdddd;

	reg u128 rand64_u128;
	rand64_u128 = (128u)rand64;
	
	reg u128 res;
	res = #set0_128();

	// https://www.felixcloutier.com/x86/pshufd
	rand32_u128 = #VPSHUFD(rand32_u128, 0x45); // bin: 01 00 01 01 -> third position is the 32 bit value, other positions are shifted to 0

	rand32_u128 |= rand64_u128;











	// reg u64 rand64;
	// #inline rand64 = random64();

	// reg u32 rand32;
	// #inline rand32 = random32();

	// reg u128 res;
	// res = (128u)rand64;

	// res <<= 32;
	// reg u128 temp;
	// temp = (128u)rand32;
	// res |= temp;
	// res <<= 32;




	// res = 0;

	// #inline res = random128();

	// reg u128 mask;
	// mask = 0xFFFFFFFFFFFFFFFFFFFFFFFF00000000;

	// // set 32 LSB to 0 for res
	// res &= mask;


	return rand32_u128;
}

export fn endianness64() -> reg u64 {
	reg u64 res;
	res = 0x0123456789abcdef;
	return res;
}

export fn endianness128() -> reg u128 {
	reg u128 res;
	reg u64 res64;
	res64 = 0x0123456789abcdef;
	res = (128u)res64;
	return res;
}
