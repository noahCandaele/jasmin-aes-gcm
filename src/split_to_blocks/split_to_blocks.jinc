u32 NB_BYTES_FULL_BLOCK_u32 = 16;
u64 NB_BYTES_FULL_BLOCK_u64 = 16;

/// Retrieves a block of data from a given memory address and stores it in another memory address.
/// 
/// # Arguments
/// 
/// * `ptr_data` - The memory address of the data.
/// * `ptrout_block` - The memory address where the block will be stored.
/// * `data_length` - The length of the data given by ptr_data.
/// * `block_id` - The ID of the block to retrieve.
inline fn get_block(reg u64 ptr_data, reg u64 ptrout_block, reg u32 data_length, reg u32 block_id) {
	ptr_data = ptr_data;
	ptrout_block = ptrout_block;
	data_length = data_length;
	block_id = block_id;

	// Start computing addr of the block
	reg u64 block_addr;
	block_addr = ptr_data;
	
	// Compute last block size
	reg u32 last_block_size;
	last_block_size = data_length;
	last_block_size %= NB_BYTES_FULL_BLOCK_u32;

	reg bool is_b;
	reg u8 temp temp2 temp3;

	is_b = last_block_size > 0;
	temp2 = #SETcc(is_b); // SETcc stores a byte at the destination specified by the effective address or register if the condition is met, or a 0 byte if the condition is not met.
	reg u64 nb;
	nb = (64u)data_length;
	nb /= NB_BYTES_FULL_BLOCK_u64;
	is_b = block_id == nb;
	temp3 = #SETcc(is_b);
	temp = temp2 & temp3;

	if (temp == 1) { // Check if we want to get the last block and if it is not full

		reg u32 last_block;
		last_block = data_length;
		last_block %= NB_BYTES_FULL_BLOCK_u32;

		inline int i;
		for i = 0 to 16 {
			reg u32 i_u32;
			i_u32 = i;
			if i_u32 < last_block {
				reg u64 temp block_id64;
				temp = 16;
				block_id64 = (64u)block_id;
				temp *= block_id64;
				temp += ptr_data;
				temp += (64u)i;
				(u8)[ptrout_block] = (u8)[temp];
			}else{
				(u8)[ptrout_block] = 0;
			}
			ptrout_block += 1;
		}
	} else { // Get a full block
		reg u64 offset;
		offset = (64u)block_id;
		offset *= NB_BYTES_FULL_BLOCK_u64;
		block_addr += offset;
		reg u128[1] block_content;
		block_content[0] = (u128)[block_addr];
		(u128)[ptrout_block] = block_content[0];
	}
}

// If the data is reversed, use this function
inline fn get_block_reverse(reg u64 ptr_data, reg u64 ptrout_block, reg u32 data_length, reg u32 block_id) {
	ptr_data = ptr_data;
	ptrout_block = ptrout_block;
	data_length = data_length;
	block_id = block_id;

	// Start computing addr of the block
	reg u64 block_addr;
	block_addr = (64u)data_length;
	block_addr += ptr_data;
	
	// Compute last block size
	reg u32 last_block_size;
	last_block_size = data_length;
	last_block_size %= NB_BYTES_FULL_BLOCK_u32;

	reg bool is_b;
	reg u8 temp temp2 temp3;

	is_b = last_block_size > 0;
	temp2 = #SETcc(is_b); // SETcc stores a byte at the destination specified by the effective address or register if the condition is met, or a 0 byte if the condition is not met.
	reg u64 nb;
	nb = (64u)data_length;
	nb /= NB_BYTES_FULL_BLOCK_u64;
	is_b = block_id == nb;
	temp3 = #SETcc(is_b);
	temp = temp2 & temp3;

	if (temp == 1) { // Check if we want to get the last block and if it is not full

		reg u32 last_block;
		last_block = data_length;
		last_block %= NB_BYTES_FULL_BLOCK_u32;

		inline int i;
		for i = 0 to 16 {
			reg u32 i_u32;
			i_u32 = i;
			if i_u32 < last_block {
				reg u64 temp;
				temp = ptr_data;
				temp += (64u)i;
				(u8)[ptrout_block] = (u8)[temp];
			}else{
				(u8)[ptrout_block] = 0;
			}
			ptrout_block += 1;
		}
	} else { // Get a full block
		reg u64 offset;
		offset = (64u)block_id;
		offset += 1;
		offset *= NB_BYTES_FULL_BLOCK_u64;
		block_addr -= offset;
		reg u128[1] block_content;
		block_content[0] = (u128)[block_addr];
		(u128)[ptrout_block] = block_content[0];
	}
}
