require "../split_to_blocks/split_to_blocks.jazz"
require "../aes/aes.jazz"
require "../random_generator/random.jinc"

inline fn incr_iv(reg u128 iv) -> reg u128 {
	// Extract counter from iv
	reg u32 counter;
	counter = #VPEXTR_32(iv, 3); // extract 0th 32-bit word from a 128-bit word
	
	// Swap bytes
	reg u32 counter_inv;
	counter_inv = #BSWAP_32(counter);

	// Increment counter
	counter_inv += 1;

	// Swap bytes
	counter = #BSWAP_32(counter_inv);

	// Insert counter in iv
	iv = #VPINSR_4u32(iv, counter, 3); // insert 32-bit word to Oth 32-bit word in a 128-bit word
	return iv;
}

// TODO check if the user is not giving a string of size longer than counter max size
// inline fn aes_counter(reg u64 ptr_plain, reg u64 ptrout_cipher, reg u64 length, reg u128 key, reg u128 iv) {
// 	reg u64 byte_index block_id;
// 	block_id = 0;
// 	byte_index = 0;

// 	while(byte_index < length) {
// 		reg u64 addr_ptrout;
// 		addr_ptrout = ptrout_cipher;

// 		addr_ptrout += byte_index;
// 		// get a block of 16 bytes from the input string
// 		reg u128 block;

// 		block = get_block(ptr_plain, length, block_id);
// 		(u128)[addr_ptrout] = block;
// 		reg u128 result;

// 		// SPILL
// 		stack u64 s_byte_index s_block_id;
// 		stack u64 s_addr_ptrout;
// 		s_byte_index = byte_index;
// 		s_block_id = block_id;
// 		s_addr_ptrout = addr_ptrout;

// 		result = aes(key, iv);

// 		// UNSPILL
// 		addr_ptrout = s_addr_ptrout;



// 		reg u128 plain;
// 		// save the result in out
// 		plain = (u128)[addr_ptrout];
// 		result ^= plain;
// 		(u128)[addr_ptrout] = result;

// 		// increment the IV
// 		iv = incr_iv(iv);
		
// 		// if needed to return the IV for debugging
// 		// (u128)[addr_ptrout] = iv;
		
// 		// UNSPILL
// 		byte_index = s_byte_index;
// 		block_id = s_block_id;

// 		// increment the block id
// 		block_id += 1;
// 		byte_index += 16;
// 	}
// }


inline fn aes_counter(reg u64 ptr_plain, reg u64 ptrout_cipher, reg u64 length, reg u128 key, reg u128 iv) {
	reg u128[11] rkeys;
	rkeys = keys_expand(key);

	reg u64 len16;
	len16 = length;
	len16 &= ((-1) << 4);
	reg u64 max;
	max = ptrout_cipher;
	max += len16;

	while (ptrout_cipher < max) {
		reg u128 plain;
		plain = (u128)[ptr_plain];
		reg u128 cipher;
		cipher = aes_rounds(rkeys, iv);
		cipher ^= plain;

		(u128)[ptrout_cipher] = cipher;

		iv = incr_iv(iv);
		ptrout_cipher += 16;
		ptr_plain += 16;
	}

	
	if (length > len16) { // last block not full
		reg u64 nb_blocks;
		nb_blocks = length;
		nb_blocks >>= 4;

		reg u128 plain;
		plain = get_block(ptr_plain, length, nb_blocks);
		reg u128 cipher;
		cipher = aes_rounds(rkeys, iv);
		cipher ^= plain;

		stack u128[1] s_cipher; s_cipher[0] = cipher;
		reg u64 i; i = 0;
		reg u64 last_byte;
		last_byte = length;
		last_byte -= len16;
		while (i < last_byte) {
			(u8)[ptrout_cipher] = s_cipher[u8 i];

			i += 1;
			ptrout_cipher += 1;
		}
	}
}
