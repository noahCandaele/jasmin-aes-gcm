require "../split_to_blocks/split_to_blocks.jazz"
require "../aes/aes.jazz"
require "../random_generator/random.jazz"

// TODO check if the user is not giving a string of size longer than counter max size
inline fn aes_counter(reg u64 ptr_plain, reg u64 ptrout_cipher, reg u32 length, reg u128 key, reg u128 iv) {
	reg u32 bit_index block_id counter;
	block_id = 0;
	bit_index = 0;

	while(bit_index < length){
		reg u64 addr_ptrout bit_index_u64;
		addr_ptrout = ptrout_cipher;

		bit_index_u64 = (64u)bit_index;
		addr_ptrout += bit_index_u64;
		// get a block of 16 bytes from the input string
		reg u64 ptr_plain_reg; // TODO remove
		ptr_plain_reg = ptr_plain;
		shrinking(ptr_plain_reg, addr_ptrout, length, block_id);

		reg u128 result plain;
		result = aes(key, iv);

		// save the result in out
		plain = (u128)[addr_ptrout];
		result ^= plain;
		(u128)[addr_ptrout] = result;

		// increment the IV
		reg u32 counter;
		counter = #VPEXTR_32(iv, 0);
		counter += 1;
		iv = #VPINSR_4u32(iv, counter, 0);

		// if needed to return the IV for debugging
		// (u128)[addr_ptrout] = iv;

		// increment the block id
		block_id += 1;
		bit_index += 16;
	}
}


export fn aes_count(reg u64 ptr_plain, reg u64 ptrout_cipher, reg u32 length, reg u64 ptr_key) {
	reg u128 key;
	key = (u128)[ptr_key];
	reg u128 iv;
	iv = iv_init();
	aes_counter(ptr_plain, ptrout_cipher, length, key, iv);
}

export fn aes_count_iv(reg u64 ptr_plain, reg u64 ptrout_cipher, reg u32 length, reg u64 ptr_key, reg u64 ptr_iv) {
	reg u128 key iv;
	key = (u128)[ptr_key];
	iv = (u128)[ptr_iv];
	aes_counter(ptr_plain, ptrout_cipher, length, key, iv);
}
