require "../split_to_blocks/split_to_blocks.jazz"
require "../aes/aes.jazz"
require "../random_generator/random.jazz"

// TODO check if the user is not giving a string of size longer than counter max size
inline fn aes_counter(reg u64 ptrin, reg u64 ptrout, reg u32 length, reg u128 key, reg u128 iv){
	reg u32 x block_id counter;
	block_id = 0;
	x = 0;

	while(x < length){
		reg u64 addr_ptrout y;
		addr_ptrout = ptrout;

		y = (64u)x;
		addr_ptrout += y;
		// get a block of 16 bytes from the input string
		shrinking(ptrin, addr_ptrout, length, block_id);

		reg u128 result plain;
		result = aes(key, iv);

		// save the result in out
		plain = (u128)[addr_ptrout];
		result ^= plain;
		(u128)[addr_ptrout] = result;

		// increment the IV
		reg u32 a;
		a = #VPEXTR_32(iv, 0);
		a += 1;
		iv = #VPINSR_4u32(iv, a, 0);

		// if needed to return the IV for debugging
		// (u128)[addr_ptrout] = iv;

		// increment the block id
		block_id += 1;
		x += 16;
	}
}


export fn aes_count(reg u64 ptrin, reg u64 ptrout, reg u32 length, reg u64 key){
	// reg u128 iv;
	// reg u128 key_128;
	// key_128 = (u128)[key];
	// #inline iv = iv_init();
	// aes_counter(ptrin, ptrout, length, key_128, iv);
}

export fn aes_count_iv (reg u64 ptrin, reg u64 ptrout, reg u32 length, reg u64 key, reg u64 iv){
	reg u128 key_128 iv_128;
	key_128 = (u128)[key];
	iv_128 = (u128)[iv];
	aes_counter(ptrin, ptrout, length, key_128, iv_128);
}
