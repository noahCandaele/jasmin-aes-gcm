/* The user has to specify a storage for each variable: either reg or stack. */
export fn f1 () -> reg u64 {
	reg u64 res; // res will be compiled into a register
	stack u64 s; // s will end up on the stack

	s = 0;
	res = s;

	return res;
}

/* Jasmin features stack arrays. */
export fn f2 () -> reg u64 {
	reg u64 res;
	stack u64[3] s; // 3 cells of 64 bits

	s[0] = 0;
	res = s[0];

	return res;
}

/* We have loops: for loops are systematically fully unrolled. */
export fn f3 () -> reg u64 {
	reg u64 res;
	stack u64[3] s;
	inline int i;
	// i is declared as inline, because it will disappear during compilation

	for i = 0 to 3 {
		s[i] = 1;
	}
	// The for loop will be compiled as:
	//   s[0] = 1;
	//   s[1] = 1;
	//   s[2] = 1;

	res = s[0];
	for i = 1 to 3 {
		res += s[i];
	}

	return res;
}

/* This is the same function using while instead of for loops
   While loops are compiled using goto. */
export fn f3_2 () -> reg u64 {
	reg u64 res;
	stack u64[3] s;
	reg u64 i;
	// i is now a register

	i = 0;
	while (i < 3) {
		s[(int)i] = 1;
		i+=1;
	}

	res = s[0];
	i = 1;
	while (i < 3) {
		res += s[(int)i];
	}

	return res;
}

/* We also have reg arrays, but those are compiled into standard registers.
   Thus, the indices must be known at compile-time.
*/

/* This works. */
export fn f4 () -> reg u64 {
	reg u64 res;
	reg u64[3] r;
	inline int i;
	// i is declared as inline, because it will disappear during compilation

	for i = 0 to 3 {
		r[i] = 1;
	}
	// The for loop will be compiled as:
	//   r[0] = 1;
	//   r[1] = 1;
	//   r[2] = 1;

	res = r[0];
	for i = 1 to 3 {
		res += r[i];
	}

	return res;
}

/* This does not work, because i is not known at compile-time. */
export fn f4_2 () -> reg u64 {
	reg u64 res;
	reg u64[3] r;
	reg u64 i;
	// i is now a register

	i = 0;
	while (i < 3) {
		r[(int)i] = 1;
		// array expansion: cannot expand variable s (the index is not a constant)
    	i+=1;
	}

	res = r[0];
	i = 1;
	while (i < 3) {
		res += r[(int)i];
	}

	return res;
}
