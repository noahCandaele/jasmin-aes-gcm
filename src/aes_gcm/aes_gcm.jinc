require "../ghash/ghash.jinc"
require "../aes/aes.jinc"
require "../aes_counter/aes_counter.jinc"
require "../split_to_blocks/split_to_blocks.jinc"

u64 NB_BYTES_FULL_BLOCK = 16;

// Hash Key: encipher the zero 128-bit string
inline fn compute_hash_key(reg u128 key) -> reg u128 {
	reg u128 var; var = #set0_128();
	var = aes(key, var);
	return var;
}

// Enciphered IV: encipher the IV (with counter 0) using AES
inline fn compute_enciphered_iv(reg u128 key, reg u128 iv) -> reg u128 {
	// // Set counter part to 0
	// reg u64 temp;
	// temp = #VPEXTR_64(iv, 1);
	// temp <<= 32;
	// temp >>= 32;
	// iv = #VPINSR_2u64(iv, temp, 1);

	// Encipher the IV
	reg u128 enc_iv; enc_iv = aes(key, iv);
	return enc_iv;
}

// Computes the length string, which has a size of 1 block (128 bits).
// We will use the length string to compute the authentication tag.
// The 64 first bits are the length of the authentication data in bits.
// The 64 last bits are the length of the plain in bits.
// The inputs are in bytes.
inline fn compute_length_str(reg u64 length_auth_data, reg u64 length_plain) -> reg u128 {
	reg u128 length_str; length_str = #set0_128();
	reg u64 temp; temp = length_auth_data;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = (128u)temp;
	temp = length_plain;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = #VPINSR_2u64(length_str, temp, 1);
	return length_str;
}

inline fn swap_bytes(reg u128 x) -> reg u128 {
	global u128 swap; swap = (16u8)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
	x = #VPSHUFB_128(x, swap);
	return x;
}

fn ghash_series(reg u128 prev_ghash, reg u64 ptr_data, reg u64 length, reg u128 hash_key) -> reg u128 {
	reg u64 len16;
	len16 = length;
	len16 &= ((-1) << 4);
	reg u64 max;
	max = ptr_data;
	max += len16;

	reg u128 block;
	reg u128 mask higher_mask lower_mask;
	mask = AND_MASK[u128 0];
	higher_mask = HIGHER_MASK_INV[u128 0];
	lower_mask = LOWER_MASK_INV[u128 0];
	while (ptr_data < max) {
		block = (u128)[ptr_data];

		block = swap_bytes(block);

		
		prev_ghash = ghash_xor_bis(prev_ghash, block, hash_key, mask, higher_mask, lower_mask);

		ptr_data += 16;
	}

	if (length > len16) { // last block not full
		reg u64 nb_blocks;
		nb_blocks = length;
		nb_blocks >>= 4;

		reg u128 block;
		stack u128[1] s_data;
		reg u64 i; i = 0;
		reg u64 last_byte;
		last_byte = length;
		last_byte -= len16;
		reg u64 n; n = 16; n -= last_byte;
		reg u128 zero; zero = #set0_128();
		s_data[0] = zero;

		while (i < last_byte) {
			s_data[u8 i] = (u8)[ptr_data];
			
			i += 1;
			ptr_data += 1;
		}
		block = s_data[0];

		block = swap_bytes(block);
		prev_ghash = ghash_xor_bis(prev_ghash, block, hash_key, mask, higher_mask, lower_mask);
	}
	
	return prev_ghash;
}

export fn ghash_series_log(reg u64 ptr_data, reg u64 length, reg u64 ptr_hash_key, reg u64 ptr_ghashes) {
	reg u128 hash_key; hash_key = (u128)[ptr_hash_key];
	
	reg u64 len16;
	len16 = length;
	len16 &= ((-1) << 4);
	reg u64 max;
	max = ptr_data;
	max += len16;

	reg u128 prev_ghash;
	prev_ghash = #set0_128();

	reg u128 block;
	while (ptr_data < max) {
		block = (u128)[ptr_data];

		block = swap_bytes(block);
		prev_ghash = ghash_xor(prev_ghash, block, hash_key);

		(u128)[ptr_ghashes] = prev_ghash;
		ptr_ghashes += 16;

		ptr_data += 16;
	}

	if (length > len16) { // last block not full
		reg u64 nb_blocks;
		nb_blocks = length;
		nb_blocks >>= 4;

		reg u128 block;
		stack u128[1] s_data;
		reg u64 i; i = 0;
		reg u64 last_byte;
		last_byte = length;
		last_byte -= len16;
		reg u64 n; n = 16; n -= last_byte;
		reg u128 zero; zero = #set0_128();
		s_data[0] = zero;

		while (i < last_byte) {
			s_data[u8 i] = (u8)[ptr_data];
			
			i += 1;
			ptr_data += 1;
		}
		block = s_data[0];

		block = swap_bytes(block);
		prev_ghash = ghash_xor(prev_ghash, block, hash_key);

		(u128)[ptr_ghashes] = prev_ghash;
	}
}

export fn aes_gcm(reg u64 ptr_args, reg u64 length_auth_data, reg u64 length_plain) {
	reg u64 ptr_values; ptr_values = ptr_args;

	// ********  CIPHER LOOP ********
	reg u64 ptr_key; ptr_key = (u64)[ptr_values];
	reg u128 key; key = (u128)[ptr_key];
	reg u64 ptr_iv; ptr_iv = (u64)[ptr_values + 8];
	reg u128 iv; iv = (u128)[ptr_iv];
	reg u64 ptr_plain; ptr_plain = (u64)[ptr_values + 24];
	reg u64 ptrout_cipher; ptrout_cipher = (u64)[ptr_values + 40];

	reg u32 counter; counter = 2;
	iv = set_iv_counter(iv, counter);
	aes_counter(ptr_plain, ptrout_cipher, length_plain, key, iv);

	// ********  GHASH AUTHENTICATION DATA LOOP ********
	reg u64 ptr_auth_data; ptr_auth_data = (u64)[ptr_values + 16];
	reg u128 ghash; ghash = #set0_128();

	reg u128 hash_key; hash_key = compute_hash_key(key);

	hash_key = swap_bytes(hash_key);
	ghash = ghash_series(ghash, ptr_auth_data, length_auth_data, hash_key);

	// ********  GHASH CIPHER LOOP ********
	ptrout_cipher = (u64)[ptr_values + 40];
	
	reg u128 length_str; length_str = compute_length_str(length_auth_data, length_plain);
	length_str = swap_bytes(length_str);

	reg u64 ptrout_cipher2; ptrout_cipher2 = ptrout_cipher;
	reg u64 length_plain2; length_plain2 = length_plain;
	ghash = ghash_series(ghash, ptrout_cipher2, length_plain2, hash_key);
	
	
	// ********  AUTHENTICATION TAG ********
	reg u64 ptrout_auth_tag; ptrout_auth_tag = (u64)[ptr_values + 32];
	length_str = length_str;
	ghash = ghash_xor(ghash, length_str, hash_key);
	reg u32 counter; counter = 1; iv = (u128)[ptr_iv];
	iv = set_iv_counter(iv, counter);
	reg u128 enc_iv; enc_iv = compute_enciphered_iv(key, iv);
	enc_iv = swap_bytes(enc_iv);
	reg u128 auth_tag;
	auth_tag = ghash ^ enc_iv;
	auth_tag = swap_bytes(auth_tag);

	(u128)[ptrout_auth_tag] = auth_tag;
}

// export fn aes_gcm(reg u128 key, reg u128 iv, reg u64 ptr_auth_data, reg u64 length_auth_data, reg u64 ptr_plain, reg u64 length_plain, reg u64 ptrout_auth_tag, reg u64 ptrout_cipher) {
// export fn aes_gcm(reg u64 ptr_args, reg u64 length_auth_data, reg u64 length_plain) {
// 	length_auth_data = length_auth_data;
// 	length_plain = length_plain;

// 	// ********  AUTHENTICATION DATA LOOP ********
// 	reg u64 nb_blocks_auth_data is_full;
	
// 	nb_blocks_auth_data = length_auth_data;
// 	nb_blocks_auth_data /= NB_BYTES_FULL_BLOCK;
// 	// nb_blocks_auth_data = large_div(length_auth_data, NB_BYTES_FULL_BLOCK); // TODO clean
	
// 	is_full = nb_blocks_auth_data;
// 	is_full *= NB_BYTES_FULL_BLOCK;
	
// 	// is_full = length_auth_data % NB_BYTES_FULL_BLOCK;
	
// 	if(is_full != length_auth_data) {
// 		nb_blocks_auth_data += 1;
// 	}
	
// 	reg u64 ptr_values; ptr_values = ptr_args;
	
// 	// Get key
// 	reg u64 ptr_key; ptr_key = (u64)[ptr_values];
// 	// reg u128 key; key = (u128)[ptr_key];
// 	reg u128 key_128; key_128 = (u128)[ptr_key];
// 	stack u128 key; key = key_128;
	
// 	// SPILL
// 	stack u64 s_nb_blocks_auth_data; s_nb_blocks_auth_data = nb_blocks_auth_data;
// 	stack u64 s_ptr_values; s_ptr_values = ptr_values;
// 	stack u64 s_length_auth_data; s_length_auth_data = length_auth_data;
// 	stack u64 s_length_plain; s_length_plain = length_plain;
	
// 	// Compute hash key
// 	stack u128 hash_key;
// 	// reg u128 hash_key; hash_key = compute_hash_key(key);
// 	hash_key = compute_hash_key(key);
// 	// UNSPILL
// 	nb_blocks_auth_data = s_nb_blocks_auth_data;
// 	ptr_values = s_ptr_values;
// 	length_auth_data = s_length_auth_data;
// 	length_plain = s_length_plain;
	
	
// 	reg u64 nb_blocks_auth_data_copy; nb_blocks_auth_data_copy = nb_blocks_auth_data;
// 	reg u64 i; i = 0;
// 	reg u128 ghash_reg; ghash_reg = #set0_128();
// 	stack u128 ghash; ghash = ghash_reg;
// 	// Get pointer on authentication data
// 	reg u64 ptr_auth_data; ptr_auth_data = (u64)[ptr_values + 16];
// 	while (i < nb_blocks_auth_data_copy) {
// 		reg u128 block_auth_data;
// 		// block_auth_data = #set0_128(); // TODO remove ?
// 		block_auth_data = get_block(ptr_auth_data, length_auth_data, i);

// 		// SPILL
// 		// stack u128 s_key; s_key = key;
// 		stack u64 s_ptr_auth_data; s_ptr_auth_data = ptr_auth_data;
// 		stack u64 s_nb_blocks_auth_data_copy; s_nb_blocks_auth_data_copy = nb_blocks_auth_data_copy;
// 		stack u64 s_ptr_values; s_ptr_values = ptr_values;
// 		stack u64 s_i; s_i = i;
// 		stack u64 s_length_auth_data; s_length_auth_data = length_auth_data;
// 		stack u64 s_length_plain; s_length_plain = length_plain;

// 		ghash = ghash_xor(ghash, block_auth_data, hash_key);

// 		// UNSPILL
// 		// key = s_key;
// 		ptr_auth_data = s_ptr_auth_data;
// 		nb_blocks_auth_data_copy = s_nb_blocks_auth_data_copy;
// 		ptr_values = s_ptr_values;
// 		i = s_i;
// 		length_auth_data = s_length_auth_data;
// 		length_plain = s_length_plain;

// 		ptr_auth_data += NB_BYTES_FULL_BLOCK;
// 		i += 1;
// 	}

// 	// Get arguments
// 	reg u64 ptr_iv ptr_plain ptrout_auth_tag ptrout_cipher;

// 	ptr_iv = (u64)[ptr_values + 8];
// 	reg u128 iv; iv = (u128)[ptr_iv];

// 	ptr_plain = (u64)[ptr_values + 24];
// 	ptrout_auth_tag = (u64)[ptr_values + 32];
// 	ptrout_cipher = (u64)[ptr_values + 40];

// 	// ******** CIPHERTEXT LOOP ********

// 	reg u64 byte_index block_id;
// 	block_id = 0;
// 	byte_index = 0;

// 	while(byte_index < length_plain) {
// 		reg u64 addr_ptrout;
// 		addr_ptrout = ptrout_cipher;

// 		addr_ptrout += byte_index;
// 		// get a block of 16 bytes from the input string
// 		reg u128 block;

// 		block = get_block(ptr_plain, length_plain, block_id);
// 		(u128)[addr_ptrout] = block;
		
// 		// SPILL
// 		stack u64 s_byte_index s_block_id;
// 		stack u128 s_hash_key;
// 		s_byte_index = byte_index;
// 		s_block_id = block_id;
// 		s_hash_key = hash_key;
		
// 		// reg u128 result;
// 		stack u128 result;
// 		// result = aes(key, iv);
		

// 		reg u128 plain;
// 		// save the result in out
// 		plain = (u128)[addr_ptrout];
// 		reg u128 r_result; r_result = result;
// 		r_result ^= plain;
// 		(u128)[addr_ptrout] = r_result;
// 		result = r_result;
		
// 		// // SPILL
// 		// stack u64 s_ptr_values; s_ptr_values = ptr_values;
// 		// stack u64 s_i; s_i = i;
// 		// stack u64 s_length_auth_data; s_length_auth_data = length_auth_data;
// 		// stack u64 s_length_plain; s_length_plain = length_plain
// 		// stack u128[2] s_keys; s_keys = #copy(key[0:2])

// 		ghash = ghash_xor(ghash, result, s_hash_key);

// 		// // UNSPILL
// 		// // key = s_key;
// 		// ptr_auth_data = s_ptr_auth_data;
// 		// nb_blocks_auth_data_copy = s_nb_blocks_auth_data_copy;
// 		// ptr_values = s_ptr_values;
// 		// i = s_i;
// 		// length_auth_data = s_length_auth_data;
// 		// length_plain = s_length_plain;

		
		
		

// 		// increment the IV
// 		// iv = incr_iv(iv);
		
// 		// if needed to return the IV for debugging
// 		// (u128)[addr_ptrout] = iv;
		
// 		// UNSPILL
// 		byte_index = s_byte_index;
// 		block_id = s_block_id;

// 		// increment the block id
// 		block_id += 1;
// 		byte_index += 16;
// 	}


// 	// ******** AUTHENTICATION TAG ********
	
// 	reg u128 length_str; length_str = compute_length_str(length_auth_data, length_plain);
// 	ghash = ghash_xor(ghash, length_str, hash_key);
// 	reg u128 enc_iv; enc_iv = compute_enciphered_iv(key, iv);
// 	reg u128 auth_tag; auth_tag = ghash_xor(ghash, enc_iv, hash_key);
// 	(u128)[ptrout_auth_tag] = auth_tag;
// }