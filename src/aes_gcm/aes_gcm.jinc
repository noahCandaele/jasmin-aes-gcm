require "../ghash/ghash.jinc"
require "../aes/aes.jinc"
require "../aes_counter/aes_counter.jinc"

// Hash Key: encipher the zero 128-bit string
inline fn compute_hash_key(reg u128 key) -> reg u128 {
	key = key;

	reg u128 zero; zero = #set0_128();
	reg u128 hash_key; hash_key = aes(key, zero);
	return hash_key;
}

// Computes the length string, which has a size of 1 block (128 bits).
// We will use the length string to compute the authentication tag.
// The 64 first bits are the length of the authentication data in bits.
// The 64 last bits are the length of the plain in bits.
// The inputs are in bytes.
inline fn compute_length_str(reg u64 length_auth_data, reg u64 length_plain) -> reg u128 {
	reg u128 length_str; length_str = #set0_128();
	reg u64 temp; temp = length_auth_data;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = (128u)temp;
	temp = length_plain;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = #VPINSR_2u64(length_str, temp, 1);
	return length_str;
}

// export fn aes_gcm(reg u128 key, reg u128 iv, reg u64 ptr_auth_data, reg u64 length_auth_data, reg u64 ptr_plain, reg u64 length_plain, reg u64 ptrout_auth_tag, reg u64 ptrout_cipher) {
export fn aes_gcm(reg u64 ptr_args) {
	reg u64 ptr_values;
	ptr_values = ptr_args;
	reg u64 ptr_key ptr_iv ptr_auth_data ptr_length_auth_data ptr_plain ptr_length_plain ptrout_auth_tag ptrout_cipher;

	ptr_key = (u64)[ptr_values];
	ptr_iv = (u64)[ptr_values + 8];
	ptr_auth_data = (u64)[ptr_values + 16];
	ptr_length_auth_data = (u64)[ptr_values + 24];
	ptr_plain = (u64)[ptr_values + 32];
	ptr_length_plain = (u64)[ptr_values + 40];
	ptrout_auth_tag = (u64)[ptr_values + 48];
	ptrout_cipher = (u64)[ptr_values + 56];

	reg u128 key; key = (u128)[ptr_key];
	reg u128 iv; iv = (u128)[ptr_iv];
	reg u64 length_auth_data; length_auth_data = (u64)[ptr_length_auth_data];
	reg u64 length_plain; length_plain = (u64)[ptr_length_plain];

	// reg u128 hash_key; hash_key = compute_hash_key(key);
	// reg u128 length_str; length_str = compute_length_str(length_auth_data, length_plain);



	// reg u32 byte_index block_id;
	// block_id = 0;
	// byte_index = 0;

	// while(byte_index < length) {
	// 	reg u64 addr_ptrout byte_index_u64;
	// 	addr_ptrout = ptrout_cipher;

	// 	byte_index_u64 = (64u)byte_index;
	// 	addr_ptrout += byte_index_u64;
	// 	// get a block of 16 bytes from the input string
	// 	get_block(ptr_plain, addr_ptrout, length, block_id);

	// 	reg u128 result;

	// 	// SPILL
	// 	stack u32 s_byte_index s_block_id;
	// 	stack u64 s_addr_ptrout;
	// 	s_byte_index = byte_index;
	// 	s_block_id = block_id;
	// 	s_addr_ptrout = addr_ptrout;

	// 	result = aes(key, iv);

	// 	// UNSPILL
	// 	addr_ptrout = s_addr_ptrout;



	// 	reg u128 plain;
	// 	// save the result in out
	// 	plain = (u128)[addr_ptrout];
	// 	result ^= plain;
	// 	(u128)[addr_ptrout] = result;

	// 	// increment the IV
	// 	iv = incr_iv(iv);
		
	// 	// if needed to return the IV for debugging
	// 	// (u128)[addr_ptrout] = iv;
		
	// 	// UNSPILL
	// 	byte_index = s_byte_index;
	// 	block_id = s_block_id;

	// 	// increment the block id
	// 	block_id += 1;
	// 	byte_index += 16;
	// }




	(u128)[ptr_key] = iv;



	// (u128)[ptr_temp] = iv;

	// ptr_auth_data
	// key = key;
	// iv = iv;
	// ptr_auth_data = ptr_auth_data;
	// length_auth_data = length_auth_data;
	// ptr_plain = ptr_plain;
	// length_plain = length_plain;
	// ptrout_cipher = ptrout_cipher;
	// ptrout_auth_tag = ptrout_auth_tag;

	// 	uint8_t* args_func[] = {key, iv, auth_data, length_auth_data, plain, length_plain, auth_tag, cipher};


	// TODO
}
