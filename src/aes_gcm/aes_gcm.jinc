require "../ghash/ghash.jinc"
require "../aes/aes.jinc"
require "../aes_counter/aes_counter.jinc"
require "../split_to_blocks/split_to_blocks.jinc"

u64 NB_BYTES_FULL_BLOCK = 16;

// Hash Key: encipher the zero 128-bit string
inline fn compute_hash_key(reg u128 key) -> reg u128 {
	key = key;

	reg u128 zero; zero = #set0_128();
	reg u128 hash_key; hash_key = aes(key, zero);
	return hash_key;
}

// Enciphered IV: encipher the IV (with counter 0) using AES
inline fn compute_enciphered_iv(reg u128 key, reg u128 iv) -> reg u128 {
	// Set counter part to 0
	reg u64 temp;
	temp = #VPEXTR_64(iv, 1);
	temp <<= 32;
	temp >>= 32;
	iv = #VPINSR_2u64(iv, temp, 1);

	// Encipher the IV
	reg u128 enc_iv; enc_iv = aes(key, iv);
	return enc_iv;
}

// Computes the length string, which has a size of 1 block (128 bits).
// We will use the length string to compute the authentication tag.
// The 64 first bits are the length of the authentication data in bits.
// The 64 last bits are the length of the plain in bits.
// The inputs are in bytes.
inline fn compute_length_str(reg u64 length_auth_data, reg u64 length_plain) -> reg u128 {
	reg u128 length_str; length_str = #set0_128();
	reg u64 temp; temp = length_auth_data;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = (128u)temp;
	temp = length_plain;
	temp *= 8;
	temp = #BSWAP_64(temp);
	length_str = #VPINSR_2u64(length_str, temp, 1);
	return length_str;
}

// export fn aes_gcm(reg u128 key, reg u128 iv, reg u64 ptr_auth_data, reg u64 length_auth_data, reg u64 ptr_plain, reg u64 length_plain, reg u64 ptrout_auth_tag, reg u64 ptrout_cipher) {
export fn aes_gcm(reg u64 ptr_args, reg u64 length_auth_data, reg u64 length_plain) {
	length_auth_data = length_auth_data;
	length_plain = length_plain;

	// ********  AUTHENTICATION DATA LOOP ********
	reg u64 nb_blocks_auth_data is_full i;
	
	nb_blocks_auth_data = length_auth_data;
	nb_blocks_auth_data /= NB_BYTES_FULL_BLOCK;
	
	is_full = nb_blocks_auth_data;
	is_full *= NB_BYTES_FULL_BLOCK;
	
	// is_full = length_auth_data % NB_BYTES_FULL_BLOCK;
	i = 0;
	
	if(is_full != length_auth_data) {
		nb_blocks_auth_data += 1;
	}

	reg u64 ptr_values; ptr_values = ptr_args;

	// Get pointer on authentication data
	reg u64 ptr_auth_data; ptr_auth_data = (u64)[ptr_values + 16];
	
	// Get key
	reg u64 ptr_key; ptr_key = (u64)[ptr_values];
	reg u128 key; key = (u128)[ptr_key];

	// Compute hash key
	reg u128 ghash; ghash = #set0_128();
	reg u128 hash_key; hash_key = compute_hash_key(key);

	while (i < nb_blocks_auth_data) {
		reg u128[1] block_auth_data;
		reg ptr u128[1] ptrout_block_auth_data;
		ptrout_block_auth_data = block_auth_data;
		//  block_auth_data = (u128)[ptr_auth_data];

		// inline fn get_block(reg u64 ptr_data, reg u64 ptrout_block, reg u64 data_length, reg u64 block_id)
		get_block(ptr_auth_data, ptrout_block_auth_data, length_auth_data, i);		
		
		// // SPILL
		// stack u128 s_key; s_key = key;
		// stack u64 s_ptr_auth_data; s_ptr_auth_data = ptr_auth_data;

		// ghash = ghash_xor(ghash, block_auth_data, hash_key);

		// // UNSPILL
		// key = s_key;
		// ptr_auth_data = s_ptr_auth_data;

		ptr_auth_data += NB_BYTES_FULL_BLOCK;
		i += 1;
	}



		


	// Get arguments
	reg u64 ptr_iv ptr_plain ptrout_auth_tag ptrout_cipher;

	ptr_iv = (u64)[ptr_values + 8];
	reg u128 iv; iv = (u128)[ptr_iv];

	ptr_plain = (u64)[ptr_values + 24];
	ptrout_auth_tag = (u64)[ptr_values + 32];
	ptrout_cipher = (u64)[ptr_values + 40];



	// ******** CIPHERTEXT LOOP ********

	// reg u64 byte_index block_id;
	// block_id = 0;
	// byte_index = 0;

	// while(byte_index < length) {
	// 	reg u64 addr_ptrout;
	// 	addr_ptrout = ptrout_cipher;

	// 	addr_ptrout += byte_index;
	// 	// get a block of 16 bytes from the input string
	// 	get_block(ptr_plain, addr_ptrout, length, block_id);

	// 	reg u128 result;

	// 	// SPILL
	// 	stack u64 s_byte_index s_block_id;
	// 	stack u64 s_addr_ptrout;
	// 	s_byte_index = byte_index;
	// 	s_block_id = block_id;
	// 	s_addr_ptrout = addr_ptrout;

	// 	result = aes(key, iv);

	// 	// UNSPILL
	// 	addr_ptrout = s_addr_ptrout;



	// 	reg u128 plain;
	// 	// save the result in out
	// 	plain = (u128)[addr_ptrout];
	// 	result ^= plain;
	// 	(u128)[addr_ptrout] = result;

	// 	// increment the IV
	// 	iv = incr_iv(iv);
		
	// 	// if needed to return the IV for debugging
	// 	// (u128)[addr_ptrout] = iv;
		
	// 	// UNSPILL
	// 	byte_index = s_byte_index;
	// 	block_id = s_block_id;

	// 	// increment the block id
	// 	block_id += 1;
	// 	byte_index += 16;
	// }



	// ******** AUTHENTICATION TAG ********
	
	// reg u128 length_str; length_str = compute_length_str(length_auth_data, length_plain);
	// ghash = ghash_xor(ghash, length_str, hash_key);
	// reg u128 enc_iv; enc_iv = compute_enciphered_iv(key, iv);
	// reg u128 auth_tag; auth_tag = ghash_xor(ghash, enc_iv, hash_key);
	// // TODO retourner auth tag


	
	// ***************** TODO RETURN VALUES? *********************
	// (u128)[ptr_temp] = iv;

	// ptr_auth_data
	// key = key;
	// iv = iv;
	// ptr_auth_data = ptr_auth_data;
	// length_auth_data = length_auth_data;
	// ptr_plain = ptr_plain;
	// length_plain = length_plain;
	// ptrout_cipher = ptrout_cipher;
	// ptrout_auth_tag = ptrout_auth_tag;
}
